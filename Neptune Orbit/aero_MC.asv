% filepath: c:\Users\ishaa\OneDrive - Imperial College London\Uni\Year 3\GDP\GDP.G4\Neptune Orbit\monte_carlo_heatshield.m
% Monte Carlo simulation for Neptune aerobraking heat shield safety factor

clear; clc; close all

%% === SETTINGS ===
N_MC = 5000; % Number of Monte Carlo runs

% Load atmospheric and wind statistics
load("gram_profiles.mat"); % rho_mean, rho_std, ew_mean, ew_std, ns_mean, ns_std, alt_steps

% Nominal values (edit as appropriate)
mu_N = 6.8351e6;         % km^3/s^2
r_N = 24622;             % km (mean radius)
r_N_equ = 24764;         % km (equatorial radius)
C_D_nom = 1.15; % or your nominal value
C_D_std = 0.05 * C_D_nom;
A = pi * 2.5^2; % m^2, or your reference area
m = 1800e6;     % kg, or your nominal mass
alt_entry_nominal = 539;                   % km, as in your script
alt_entry_std = 5;                         % km, 1-sigma

% New: Standard deviations for orbital elements
i_cap_nom = 65; i_cap_std = 3;             % deg
RAAN_cap_nom = 15; RAAN_cap_std = 1;       % deg
omega_cap_nom = 102; omega_cap_std = 1;    % deg

% Preallocate results
max_m_TPS = zeros(N_MC,1);
max_t_TPS = zeros(N_MC,1);
time_taken_days = zeros(N_MC,1);
num_passes = zeros(N_MC,1);

n_failed = 0;

for mc = 1:N_MC
    % --- Sample density and wind profiles ---
    rho_mc = rho_mean + randn(size(rho_mean)) .* rho_std;
    ew_mc  = ew_mean  + randn(size(ew_mean))  .* ew_std;
    ns_mc  = ns_mean  + randn(size(ns_mean))  .* ns_std;

    % --- Sample beta and entry altitude ---
    C_D_mc = C_D_nom + randn * C_D_std;
    beta_mc = m / (C_D_mc * A);
    alt_entry_mc = alt_entry_nominal + randn * alt_entry_std;

    % --- Sample orbital elements ---
    i_cap_mc = i_cap_nom + randn * i_cap_std;
    RAAN_cap_mc = RAAN_cap_nom + randn * RAAN_cap_std;
    omega_cap_mc = omega_cap_nom + randn * omega_cap_std;

    % --- Build interpolant functions for this run ---
    atmos_mc = @(alt_km) interp1(alt_steps, rho_mc * 1e9, alt_km, 'linear', 0); % kg/km^3
    zonal_mc = @(alt_km) interp1(alt_steps, ew_mc/1000, alt_km, 'linear', 0);   % km/s
    merid_mc = @(alt_km) interp1(alt_steps, ns_mc/1000, alt_km, 'linear', 0);   % km/s

    try
        [m_TPS_vec, t_TPS_cm_vec, t_days, pass] = run_aerobrake_sim(atmos_mc, zonal_mc, merid_mc, beta_mc, alt_entry_mc, mu_N, r_N, r_N_equ, i_cap_mc, RAAN_cap_mc, omega_cap_mc);
        max_m_TPS(mc) = max(m_TPS_vec);
        max_t_TPS(mc) = max(t_TPS_cm_vec);
        time_taken_days(mc) = t_days;
        num_passes(mc) = pass;
    catch
        max_m_TPS(mc) = NaN;
        max_t_TPS(mc) = NaN;
        time_taken_days(mc) = NaN;
        num_passes(mc) = NaN;
        n_failed = n_failed + 1;
        fprintf('MC run %d FAILED\n', mc);
    end
    fprintf('Completed MC run %d of %d\n', mc, N_MC);
end
fprintf('Total failed MC runs: %d out of %d\n', n_failed, N_MC);

% Remove failed runs
max_m_TPS = max_m_TPS(~isnan(max_m_TPS));
max_t_TPS = max_t_TPS(~isnan(max_t_TPS));

%% === Plot Results ===

figure;
histogram(max_m_TPS, 20, 'FaceColor', [0.2 0.6 1]);
xlabel('Maximum Heat Shield Mass per MC Run (kg)');
ylabel('Count');
title('Monte Carlo: Maximum Heat Shield Mass Distribution');
grid on;

figure;
histogram(max_t_TPS, 20, 'FaceColor', [1 0.6 0.2]);
xlabel('Maximum Heat Shield Thickness per MC Run (cm)');
ylabel('Count');
title('Monte Carlo: Maximum Heat Shield Thickness Distribution');
grid on;

% Remove failed runs for all outputs
valid = ~isnan(max_m_TPS) & ~isnan(time_taken_days) & ~isnan(num_passes);
time_taken_days = time_taken_days(valid);
num_passes = num_passes(valid);

% Plot histogram for time taken (days)
figure;
histogram(time_taken_days, 10, 'FaceColor', [0.3 0.7 0.3]);
xlabel('Time Taken (days)');
ylabel('Count');
title('Monte Carlo: Time Taken Distribution');
grid on;

% Plot histogram for number of passes
figure;
histogram(num_passes, 'FaceColor', [0.7 0.3 0.7]);
xlabel('Number of Passes');
ylabel('Count');
title('Monte Carlo: Number of Passes Distribution');
grid on;

fprintf('Mean max heat shield mass: %.2f kg\n', mean(max_m_TPS));
fprintf('99th percentile mass: %.2f kg\n', prctile(max_m_TPS,99));
fprintf('Mean max thickness: %.2f cm\n', mean(max_t_TPS));
fprintf('99th percentile thickness: %.2f cm\n', prctile(max_t_TPS,99));

%% === Helper function: run_aerobrake_sim ===
function [m_TPS_vec, t_TPS_cm_vec, t_days, num_passes] = run_aerobrake_sim(atmos, zonal, merid, beta, alt_entry, mu_N, r_N, r_N_equ, i_cap, RAAN_cap, omega_cap)
    % Initial orbit setup (as in your main script)
    alt_cap = 10000;                      % km above surface
    rp_cap = alt_cap + r_N;
    e_cap = 1;
    vp_cap = sqrt(2 * mu_N/rp_cap);       % km/s
    % Use sampled i_cap, RAAN_cap, omega_cap
    [rp_cap_vec, vp_cap_vec] = rv_parabolic(rp_cap, vp_cap, i_cap, RAAN_cap, omega_cap);

    dv_init = 0.22;                               % km/s
    vp_init = vp_cap - dv_init;
    rp_init_vec = rp_cap_vec;
    vp_init_vec = vp_cap_vec * (1 - dv_init/vp_cap);
    [a_init, e_init, h_init, i_init, RAAN_init, omega_init, ~] = oe_from_rv(rp_init_vec, vp_init_vec, mu_N);
    [ra_init_vec, va_init_vec] = rv_from_oe(a_init, e_init, i_init, RAAN_init, omega_init, 180, mu_N);
    ra_init = norm(ra_init_vec);
    va_init = norm(va_init_vec);

    % Use the sampled entry altitude (fixed for all passes)
    alt_brake = alt_entry;
    rp_brake = r_N + alt_brake;
    ra_brake = ra_init;
    e_brake = (ra_brake - rp_brake)./(ra_brake + rp_brake);
    a_brake = 0.5 * (ra_brake + rp_brake);
    h_brake = sqrt(mu_N * a_brake .* (1 - e_brake.^2));
    va_pre_brake = h_brake/ra_brake;
    va_post_brake = va_init;
    i_brake = i_init; RAAN_brake = RAAN_init; omega_brake = omega_init;
    [ra_brake_init, va_brake_init] = rv_from_oe(a_brake, e_brake, i_brake, RAAN_brake, omega_brake, 180, mu_N);
    Y0 = [ra_brake_init;va_brake_init];

    % Integrate until e < 0.45 at apogee (or your science orbit condition)
    opts = odeset('RelTol',1e-9, 'AbsTol',1e-9, ...
                  'Events', @(t, Y) stop_when_reached_science(t, Y, mu_N));
    [t_out, Y_out] = ode113(@(t, Y) eom_perturbed(t, Y, mu_N, r_N, r_N_equ, atmos, zonal, merid, beta, ["drag"]), ...
                            [0, 2.5 * 365.25 * 86400], Y0, opts);

    % Post-process to find passes and heat shield requirements
    altitudes = vecnorm(Y_out(:,1:3), 2, 2) - r_N;
    in_atmos = altitudes <= 4000;
    entry_idx = find(diff(in_atmos) == 1);         % Just before entry
    exit_idx = find(diff(in_atmos) == -1) + 1;     % Just after exit
    N = min(length(entry_idx), length(exit_idx));
    m_TPS_vec = zeros(1, N);
    t_TPS_cm_vec = zeros(1, N);

    for i = 1:N
        idx_entry = entry_idx(i)+1; % first entry within atmosphere
        idx_exit = exit_idx(i)-1;   % last point within atmosphere

        % Extract profiles within the atmosphere for this pass
        t_pass = t_out(idx_entry:idx_exit) - t_out(idx_entry); % seconds, start from 0
        alt_pass = altitudes(idx_entry:idx_exit);              % km
        v_pass = vecnorm(Y_out(idx_entry:idx_exit,4:6),2,2);   % km/s

        % Call HeatShieldMass
        [m_TPS, t_TPS_cm] = HeatShieldMass(alt_pass, v_pass, t_pass);

        m_TPS_vec(i) = m_TPS;
        t_TPS_cm_vec(i) = t_TPS_cm;
    end

    t_days = t_out(end)/(24*3600);
    num_passes = N;
end

%% === Event function for apogee ===
function [value, isterminal, direction] = stop_when_reached_science(~, Y, mu)
    r = Y(1:3); v = Y(4:6);
    [~, e, ~, ~, ~, ~, theta] = oe_from_rv(r, v, mu);

    % Condition 1: e < 0.45 and at apogee
    cond1 = e - 0.45;
    cond2 = abs(mod(theta,360) - 180) - 10;
    event1 = max([cond1, cond2]); % triggers when both < 0

    % Condition 2: collision with Neptune (r <= r_N)
    r_N = 24622; % km (should match your main code)
    r_mag = norm(r);
    event2 = r_mag - r_N; % triggers when <= 0

    value = [event1, event2];
    isterminal = [1, 1];
    direction = [-1, -1];
end
%% === Equations of motion with drag ===
function dY = eom_perturbed(~, Y, mu, R, R_equ, atmos, zonal, merid, beta, perturbations)
    r = Y(1:3); v = Y(4:6);
    r_norm = norm(r);
    a_total = -mu * r / r_norm^3;

    for k = 1:length(perturbations)
        switch perturbations{k}
            case "drag"
                if r_norm - R <= 4000
                    a_total = a_total + drag_acc(r, v, R, atmos, zonal, merid, beta);
                end
        end
    end

    dY = [v; a_total];
end

%% === Drag acceleration with variable beta ===
function a_drag = drag_acc(r, v, R, atmos, zonal_model, meridional_model, beta)
    omega_N = [0; 0; 2 * pi/(16.11 * 3600)];
    v_rel = v - cross(omega_N, r) - v_wind_inertial(r, R, zonal_model, meridional_model);
    rho = atmos(norm(r) - R);
    a_drag = -0.5 * rho * norm(v_rel) * v_rel / beta;
end

%% === Wind function ===
function v_wind_inertial = v_wind_inertial(r_vec, R, zonal_model, meridional_model)
    x = r_vec(1); y = r_vec(2); z = r_vec(3);
    r_mag = norm(r_vec);
    alt = r_mag - R;
    lat = asind(z / r_mag);
    lon = atan2d(y, x);
    lat_rad = deg2rad(lat);
    lon_rad = deg2rad(lon);
    e_hat = [-sind(lon_rad); cosd(lon_rad); 0];
    n_hat = [-sind(lat_rad)*cosd(lon_rad);
             -sind(lat_rad)*sind(lon_rad);
              cosd(lat_rad)];
    v_zonal = zonal_model(alt);
    v_meridional = meridional_model(alt);
    v_wind_inertial = v_zonal * e_hat + v_meridional * n_hat;
end