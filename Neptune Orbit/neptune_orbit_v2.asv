clear
clc
close all

%% SET GRAPHING FONTS AND SIZES
set(groot,'defaultLineLineWidth',4) % Set all line widths to 2 unless stated otherwise
set(groot,'defaultAxesFontSize',34) % Set all axes font size to 16 unless stated otherwise
set(groot,'defaulttextfontsize',36) % Set all text font sizes to 16 unless stated otherwise
set(groot,'defaultLineMarkerSize',12) % Set all marker sizes to 16 unless stated otherwise
set(groot,'defaultAxesXGrid','on') % Turn x grid lines on
set(groot,'defaultAxesYGrid','on') % Turn y grid lines on

%% Orbit around Neptune 

% Neptune Orbital Trajectory Design
% Author: Team 04 - Trajectory Design
% Date: May 2025

%% === CONSTANTS ===
mu_S = 1.32712440018e11;      % Sun gravitational parameter [km^3/s^2]
mu_N = 6.8365e6;              % Neptune gravitational parameter [km^3/s^2]
R_N = 24760;                  % Neptune radius [km]
R_T = 13526;

% == Conversion to Vector Form == 
% r_sc_sun = [; ; ]; 
% v_sc_sun = [; ; ];       
% 
% % Heliocentric position and velocity of Neptune at arrival (get from JPL Horizons)
% r_N_sun = [...];  % [x; y; z] in km
% v_N_sun = [...];  % [vx; vy; vz] in km/s
% 
% r_sc_N = r_sc_sun - r_N_sun;      % Neptune-relative position and velocity
% v_sc_N = v_sc_sun - v_N_sun;  
% v_hat_sc = v_sc_N / norm(v_sc_N);      % Use original direction but scale to parabolic speed
% v_parabolic_vec = v_parabolic * v_hat_sc;
% Compute Neptune-centric orbital elements 
% You may have a function like this:
% [a, e, i, RAAN, omega, nu] = rv2coe(r_rel, v_parabolic_vec, mu_N);


% WAITING FOR BENS VECTORS - post aerocapture so around 

% r_sc_N = ;
% v_sc_N = ;

% r_mag_sc_N = norm(r_sc_N);                  % This will be elliptical perigee  
% 
% % == Initial Elliptical Capture Orbit ==
% ra_cap = 7.7455e+06;                     
% rp_cap = r_mag_sc_N;
% a_cap = (rp_cap + ra_cap) / 2;
% e_cap = (ra_cap - rp_cap) / (ra_cap + rp_cap);
% h_cap = sqrt(mu_N * rp_cap * (1 + e_cap));
% vp_cap = h_cap / rp_cap;

% Periapsis increase Maneuver / Plane change 

%dv_planechange 

% ra = t_triton_norm 


% for varying perigee (same inclination- unless no xsollution_
% calculate orbital elememts  for orbital eq (h,e)
% solve for when r = r_Triton from orbital eq
% calculate theta from here 
% convert to time - from apoapsis to this point in theta 
% see where triton is 


%% === TRITON PROPERTIES ===
if exist('moon_orbits.mat', 'file') ~= 2 
    load_moon_data()
end 
load('moon_orbits.mat','orbits_mat','moon_names', 'max_len', 'times_all', 'velocities_mat');
triton_orbit = [orbits_mat(:, :, 14),velocities_mat(:,:,14)];
triton_times = times_all{14};


arrival_epoch = 14762.860319752668; % MJD2000
arrival_epoch = arrival_epoch + 2451545.0; 

interpolated_time = interp1(triton_times, triton_orbit, arrival_epoch, 'spline');

r_Triton_0 = interpolated_time(1, 1:3);
v_Triton_0 = interpolated_time(1, 4:6);

% r_Triton_mag = norm(r_Triton_0);
% v_Triton_mag = norm(v_Triton_0);
% Triton_omega = v_Triton_mag / r_Triton_mag; % Angular speed [rad/s]

[a_triton, e_triton, h_triton, i_triton, Omega_triton, omega_triton, ~] = find_OE(r_Triton_0, v_Triton_0, mu_N);

%% Get initial spacecraft orbit

% === HIGHLY ELLIPTICAL ORBIT ===
% BENS VECTORS 
% r_sc_initial = [1.9793e+04; 1.5867e+04; 0];
% v_sc_initial = [1.2467e+01; -1.2873e+01; 0];

ra_cap = 5.634e6;           % Apoapsis [km]
rp_cap = R_N + 184.6;       %184.6          % Periapsis [km] (initial guess - can change now - no more aerocapture - doesnt change much if 2000km ect)
a_cap = (rp_cap + ra_cap)/2;
e_cap = (ra_cap - rp_cap)/(ra_cap + rp_cap);
h_cap = sqrt(mu_N * rp_cap * (1 + e_cap));
i_cap = 180 - i_triton;
Omega_cap = Omega_triton-180;
omega_cap = 90;
[r0_sc, v0_sc] = rv_from_oe(a_cap, e_cap, i_cap, Omega_cap, omega_cap, 180, mu_N);

figure 
hold on
plotOrbit(a_triton, e_triton, i_triton, Omega_triton, omega_triton, mu_N, 'Triton')
plotOrbit(a_cap, e_cap, i_cap, Omega_cap, omega_cap, mu_N, 'spacecraft')
axis equal
legend()


%% Triton at apogee

P = 2 * pi * sqrt(a_cap^3/mu_N);
tof_a = P/2; 

ap_epoch = arrival_epoch + tof_a / (3600 * 24);

statevector = interp1(triton_times, triton_orbit, arrival_epoch, 'spline');

r_Triton_ap = statevector(1, 1:3);
v_Triton_ap = statevector(1, 4:6);

%% 

rp_try = linspace(3e4, 3.6e5, 1000);

for k = 1 : length(rp_try)
    rp_int = rp_try(k);
    a_int = (rp_int + ra_cap)/2;
    e_int = (ra_cap - rp_int)/(ra_cap + rp_int);
    h_int = sqrt(mu_N * rp_int * (1 + e_int));

    theta_int = acosd((h_int^2 / (mu_N*a_triton) - 1)/e_int);
    if theta_int <=180 
        theta_int = 360-theta_int;
    end
    
    E = 2 * atan( sqrt((1 - e_int)/(1 + e_int)) * tand(theta_int/2) );
    M = E - e_int * sin(E);
    if M < 0
        M = M + 2*pi;
    end
    P = 2 * pi * sqrt(a_int^3 / mu_N);
    T = M * P/(2*pi) - P/2;

    k;
    
    r_sc_int = rv_from_oe(a_int, e_int, i_cap, Omega_cap, omega_cap, theta_int, mu_N);

    int_epoch = ap_epoch + T / (3600 * 24);

    statevector = interp1(triton_times, triton_orbit, int_epoch, 'spline');
    
    r_Triton_int = statevector(1, 1:3)';


    if norm(r_Triton_int - r_sc_int) <= R_T + 5000
        rp_int
        dv_int = h_cap / ra_cap-h_int/ra_cap
        break 
    end 

end 



%% during flyby 

mu_T = 1428.495;

[~, v_sc_int] = rv_from_oe(a_int, e_int, i_cap, Omega_cap, omega_cap, theta_int, mu_N);
v_Triton_int = statevector(1, 4:6)';

v_inf_in = v_sc_int - v_Triton_int;
v_inf_in_mag = norm(v_inf_in);

a_flyby = mu_T / v_inf_in_mag^2;   %% 28/05/25 i just changed mu_N into mu_T 
rp_flyby = R_T + 1000;
e_flyby = rp_flyby/a_flyby + 1;
delta_flyby = 2*asin(1/e_flyby);

v_hat_in = v_inf_in / v_inf_in_mag;

% Step 2: Rotation plane (find perpendicular unit vector)
h_vec = cross(v_inf_in, [0; 0; 1]);   % arbitrary axis if motion isn't planar
n_hat = cross(h_vec, v_hat_in);
n_hat = n_hat / norm(n_hat);

% Step 3: Rotate v_inf_in by turn angle in the plane
v_inf_out = v_inf_in_mag * (cos(delta_flyby) * v_hat_in + sin(delta_flyby) * n_hat);

% Step 4: Back to inertial frame
v_sc_after = v_inf_out + v_Triton_int;

delta_v_flyby = norm(v_sc_after) - norm(v_sc_int)


%% Post flyby - ELYA EXPERIMENTING HERE

% imma explain what i did here before i forget, so worked out orbital
% elements after flyby, then worked out r,v at apoapsis (180deg) of this orbit then
% used that r to set the new orbits apoapsis and calculated the velocity at that same point (180deg)
% hence found dv at apoapsis to set it into new trajecto

[a_return, e_return, h_return, i_return, Omega_return, omega_return, theta_return] = find_OE(r_sc_int, v_sc_after, mu_N);
[rp_return, vp_return] = rv_from_oe(a_return, e_return, i_return, Omega_return, omega_return, 180 , mu_N) % maybe there was easier way whoops 

ra_main1 = norm(rp_return);    % then set this ra_main1 as rp_return at 180 deg  - then change to 1.2e5    
rp_main1 = R_N + 2000;       
a_main1 = (rp_main1 + ra_main1)/2;
e_main1 = (ra_main1 - rp_main1)/(ra_main1 + rp_main1);
h_main1 = sqrt(mu_N * rp_main1 * (1 + e_main1));
i_main1 = i_return;
Omega_main1 = Omega_return;
omega_main1 = omega_return;
[r0_main1, v0_main1] = rv_from_oe(a_main1, e_main1, i_main1, Omega_main1, omega_main1, 180, mu_N)

dv_return = norm(v0_main1) - norm(vp_return)











%%
% %% Plotting interception
% 
% epochs = linspace(arrival_epoch, int_epoch, 1000);
% dt = (epochs(2) - epochs(1)) * 24 * 3600;
% rs_Triton = zeros(3, length(epochs));
% rs_sc = zeros(3, length(epochs));
% theta_sc = 0;
% 
% for j = 1:length(epochs)
%     statevector = interp1(triton_times, triton_orbit, epochs(j), 'spline');
%     rs_Triton(:,j) = statevector(1, 1:3)';
% 
%     if epochs(j) < ap_epoch
%         rs_sc(:,j) = rv_from_oe(a_cap, e_cap, i_cap, omega_cap, omega_cap, theta_sc, mu_N);
%         E0 = 2 * atan( sqrt((1 - e_cap)/(1 + e_cap)) * tand(theta_sc/2) );
%         M0 = E0 - e_cap * sin(E0);
%         M1 = M0 + sqrt(mu_N/a_cap^3) * dt;
%         E1 = solve_kepler(M1, e_cap, 1e-8, 1000);
%         theta_sc = 2 * atand(sqrt((1 + e_cap)/(1 - e_cap)) * tan(E1/2));
%     else
%         rs_sc(:,j) = rv_from_oe(a_int, e_int, i_cap, omega_cap, omega_cap, theta_sc, mu_N);
%         E0 = 2 * atan( sqrt((1 - e_int)/(1 + e_int)) * tand(theta_sc/2) );
%         M0 = E0 - e_int * sin(E0);
%         M1 = M0 + sqrt(mu_N/a_int^3) * dt;
%         E1 = solve_kepler(M1, e_int, 1e-8, 1000);
%         theta_sc = 2 * atand(sqrt((1 + e_int)/(1 - e_int)) * tan(E1/2));
%     end
% 
% end
% 
% %% Animate
% 
% animate_two_trajectories([rs_sc, r_sc_int], [rs_Triton, r_Triton_int])


%%

function plotOrbit(a, e, i, Omega, omega, mu, name)
    thetas = 0:0.5:360;
    r = zeros(3, length(thetas));
    for j = 1:length(thetas)
        [r(:, j) , ~] = rv_from_oe(a, e, i, Omega, omega, thetas(j), mu);
    end

    plot3(r(1,:), r(2,:), r(3,:), DisplayName=name);  % unperturbed
end

function animate_two_trajectories(r1, r2)
    % r1, r2 are 3xN matrices; columns are position vectors over time

    % Setup figure
    figure;
    hold on;
    grid on;
    axis equal;
    xlabel('X [km]');
    ylabel('Y [km]');
    zlabel('Z [km]');
    title('Trajectory Animation');
    view(3);

    % Plot full trajectories as lines for context
    plot3(r1(1,:), r1(2,:), r1(3,:), 'b--', 'DisplayName', 'Object 1 Path');
    plot3(r2(1,:), r2(2,:), r2(3,:), 'r--', 'DisplayName', 'Object 2 Path');

    % Create animated points
    h1 = plot3(r1(1,1), r1(2,1), r1(3,1), 'bo', 'MarkerSize', 8, 'DisplayName', 'Object 1');
    h2 = plot3(r2(1,1), r2(2,1), r2(3,1), 'ro', 'MarkerSize', 8, 'DisplayName', 'Object 2');
    legend;

    % Animate
    N = size(r1, 2);
    for k = 1:N
        set(h1, 'XData', r1(1,k), 'YData', r1(2,k), 'ZData', r1(3,k));
        set(h2, 'XData', r2(1,k), 'YData', r2(2,k), 'ZData', r2(3,k));
        drawnow;
        pause(0.01); % Adjust speed here
    end
end










